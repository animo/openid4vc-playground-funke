diff --git a/build/openid4vc-verifier/OpenId4VcSiopVerifierService.js b/build/openid4vc-verifier/OpenId4VcSiopVerifierService.js
index 1d35b8285d451933101b686de77cfe8780976516..5f089575e187215ad3d10a33946e4a3edfdee68b 100644
--- a/build/openid4vc-verifier/OpenId4VcSiopVerifierService.js
+++ b/build/openid4vc-verifier/OpenId4VcSiopVerifierService.js
@@ -1,16 +1,36 @@
 "use strict";
-var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
-    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
-    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
-    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
+var __decorate =
+  (this && this.__decorate) ||
+  function (decorators, target, key, desc) {
+    var c = arguments.length,
+      r =
+        c < 3
+          ? target
+          : desc === null
+          ? (desc = Object.getOwnPropertyDescriptor(target, key))
+          : desc,
+      d;
+    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
+      r = Reflect.decorate(decorators, target, key, desc);
+    else
+      for (var i = decorators.length - 1; i >= 0; i--)
+        if ((d = decorators[i]))
+          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
     return c > 3 && r && Object.defineProperty(target, key, r), r;
-};
-var __metadata = (this && this.__metadata) || function (k, v) {
-    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
-};
-var __param = (this && this.__param) || function (paramIndex, decorator) {
-    return function (target, key) { decorator(target, key, paramIndex); }
-};
+  };
+var __metadata =
+  (this && this.__metadata) ||
+  function (k, v) {
+    if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
+      return Reflect.metadata(k, v);
+  };
+var __param =
+  (this && this.__param) ||
+  function (paramIndex, decorator) {
+    return function (target, key) {
+      decorator(target, key, paramIndex);
+    };
+  };
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.OpenId4VcSiopVerifierService = void 0;
 const core_1 = require("@credo-ts/core");
@@ -29,392 +49,635 @@ const OpenId4VcRelyingPartySessionManager_1 = require("./repository/OpenId4VcRel
  * @internal
  */
 let OpenId4VcSiopVerifierService = class OpenId4VcSiopVerifierService {
-    constructor(logger, w3cCredentialService, openId4VcVerifierRepository, config, openId4VcVerificationSessionRepository) {
-        this.logger = logger;
-        this.w3cCredentialService = w3cCredentialService;
-        this.openId4VcVerifierRepository = openId4VcVerifierRepository;
-        this.config = config;
-        this.openId4VcVerificationSessionRepository = openId4VcVerificationSessionRepository;
+  constructor(
+    logger,
+    w3cCredentialService,
+    openId4VcVerifierRepository,
+    config,
+    openId4VcVerificationSessionRepository
+  ) {
+    this.logger = logger;
+    this.w3cCredentialService = w3cCredentialService;
+    this.openId4VcVerifierRepository = openId4VcVerifierRepository;
+    this.config = config;
+    this.openId4VcVerificationSessionRepository =
+      openId4VcVerificationSessionRepository;
+  }
+  async createAuthorizationRequest(agentContext, options) {
+    var _a;
+    const nonce = await agentContext.wallet.generateNonce();
+    const state = await agentContext.wallet.generateNonce();
+    // Correlation id will be the id of the verification session record
+    const correlationId = core_1.utils.uuid();
+    const jwtIssuer = await (0, utils_1.openIdTokenIssuerToJwtIssuer)(
+      agentContext,
+      options.requestSigner
+    );
+    let clientIdScheme;
+    let clientId;
+    let authorizationResponseUrl = (0, core_1.joinUriParts)(
+      this.config.baseUrl,
+      [
+        options.verifier.verifierId,
+        this.config.authorizationEndpoint.endpointPath,
+      ]
+    );
+    if (jwtIssuer.method === "x5c") {
+      if (jwtIssuer.issuer !== authorizationResponseUrl) {
+        throw new core_1.CredoError(
+          `The jwtIssuer's issuer field must match the verifier's authorizationResponseUrl '${authorizationResponseUrl}'.`
+        );
+      }
+      const leafCertificate = core_1.X509Service.getLeafCertificate(
+        agentContext,
+        { certificateChain: jwtIssuer.x5c }
+      );
+      if (
+        leafCertificate.sanDnsNames.includes(
+          (0, core_1.getDomainFromUrl)(jwtIssuer.issuer)
+        )
+      ) {
+        clientIdScheme = "x509_san_dns";
+        clientId = (0, core_1.getDomainFromUrl)(jwtIssuer.issuer);
+        authorizationResponseUrl = jwtIssuer.issuer;
+      } else if (leafCertificate.sanUriNames.includes(jwtIssuer.issuer)) {
+        clientIdScheme = "x509_san_uri";
+        clientId = jwtIssuer.issuer;
+        authorizationResponseUrl = clientId;
+      } else {
+        throw new core_1.CredoError(
+          `With jwtIssuer 'method' 'x5c' the jwtIssuer's 'issuer' field must either match the match a sanDnsName (FQDN) or sanUriName in the leaf x509 chain's leaf certificate.`
+        );
+      }
+    } else if (jwtIssuer.method === "did") {
+      clientId = jwtIssuer.didUrl.split("#")[0];
+      clientIdScheme = "did";
+    } else {
+      throw new core_1.CredoError(
+        `Unsupported jwt issuer method '${options.requestSigner.method}'. Only 'did' and 'x5c' are supported.`
+      );
     }
-    async createAuthorizationRequest(agentContext, options) {
-        var _a;
-        const nonce = await agentContext.wallet.generateNonce();
-        const state = await agentContext.wallet.generateNonce();
-        // Correlation id will be the id of the verification session record
-        const correlationId = core_1.utils.uuid();
-        const jwtIssuer = await (0, utils_1.openIdTokenIssuerToJwtIssuer)(agentContext, options.requestSigner);
-        let clientIdScheme;
-        let clientId;
-        let authorizationResponseUrl = (0, core_1.joinUriParts)(this.config.baseUrl, [
-            options.verifier.verifierId,
-            this.config.authorizationEndpoint.endpointPath,
-        ]);
-        if (jwtIssuer.method === 'x5c') {
-            if (jwtIssuer.issuer !== authorizationResponseUrl) {
-                throw new core_1.CredoError(`The jwtIssuer's issuer field must match the verifier's authorizationResponseUrl '${authorizationResponseUrl}'.`);
-            }
-            const leafCertificate = core_1.X509Service.getLeafCertificate(agentContext, { certificateChain: jwtIssuer.x5c });
-            if (leafCertificate.sanDnsNames.includes((0, core_1.getDomainFromUrl)(jwtIssuer.issuer))) {
-                clientIdScheme = 'x509_san_dns';
-                clientId = (0, core_1.getDomainFromUrl)(jwtIssuer.issuer);
-                authorizationResponseUrl = jwtIssuer.issuer;
-            }
-            else if (leafCertificate.sanUriNames.includes(jwtIssuer.issuer)) {
-                clientIdScheme = 'x509_san_uri';
-                clientId = jwtIssuer.issuer;
-                authorizationResponseUrl = clientId;
-            }
-            else {
-                throw new core_1.CredoError(`With jwtIssuer 'method' 'x5c' the jwtIssuer's 'issuer' field must either match the match a sanDnsName (FQDN) or sanUriName in the leaf x509 chain's leaf certificate.`);
-            }
-        }
-        else if (jwtIssuer.method === 'did') {
-            clientId = jwtIssuer.didUrl.split('#')[0];
-            clientIdScheme = 'did';
-        }
-        else {
-            throw new core_1.CredoError(`Unsupported jwt issuer method '${options.requestSigner.method}'. Only 'did' and 'x5c' are supported.`);
-        }
-        const relyingParty = await this.getRelyingParty(agentContext, options.verifier.verifierId, {
-            presentationDefinition: (_a = options.presentationExchange) === null || _a === void 0 ? void 0 : _a.definition,
-            clientId,
-            clientIdScheme,
-            authorizationResponseUrl,
-        });
-        // We always use shortened URIs currently
-        const hostedAuthorizationRequestUri = (0, core_1.joinUriParts)(this.config.baseUrl, [
-            options.verifier.verifierId,
-            this.config.authorizationRequestEndpoint.endpointPath,
-            // It doesn't really matter what the url is, as long as it's unique
-            core_1.utils.uuid(),
-        ]);
-        // This is very unfortunate, but storing state in sphereon's SiOP-OID4VP library
-        // is done async, so we can't be certain yet that the verification session record
-        // is created already when we have created the authorization request. So we need to
-        // wait for a short while before we can be certain that the verification session record
-        // is created. To not use arbitrary timeouts, we wait for the specific RecordSavedEvent
-        // that is emitted when the verification session record is created.
-        const eventEmitter = agentContext.dependencyManager.resolve(core_1.EventEmitter);
-        const verificationSessionCreatedPromise = (0, rxjs_1.firstValueFrom)(eventEmitter
-            .observable(core_1.RepositoryEventTypes.RecordSaved)
-            .pipe((0, rxjs_1.filter)((e) => e.metadata.contextCorrelationId === agentContext.contextCorrelationId), (0, rxjs_1.filter)((e) => e.payload.record.id === correlationId && e.payload.record.verifierId === options.verifier.verifierId), (0, rxjs_1.first)(), (0, rxjs_1.timeout)({
-            first: 10000,
-            meta: 'OpenId4VcSiopVerifierService.createAuthorizationRequest',
-        }), (0, rxjs_1.map)((e) => e.payload.record)));
-        const authorizationRequest = await relyingParty.createAuthorizationRequest({
-            correlationId,
-            nonce,
-            state,
-            requestByReferenceURI: hostedAuthorizationRequestUri,
-            jwtIssuer,
-        });
-        // NOTE: it's not possible to set the uri scheme when using the RP to create an auth request, only lower level
-        // functions allow this. So we need to replace the uri scheme manually.
-        let authorizationRequestUri = (await authorizationRequest.uri()).encodedUri;
-        if (options.presentationExchange && !options.idToken) {
-            authorizationRequestUri = authorizationRequestUri.replace('openid://', 'openid4vp://');
-        }
-        const verificationSession = await verificationSessionCreatedPromise;
-        return {
-            authorizationRequest: authorizationRequestUri,
-            verificationSession,
-        };
+    const relyingParty = await this.getRelyingParty(
+      agentContext,
+      options.verifier.verifierId,
+      {
+        presentationDefinition:
+          (_a = options.presentationExchange) === null || _a === void 0
+            ? void 0
+            : _a.definition,
+        clientId,
+        clientIdScheme,
+        authorizationResponseUrl,
+      }
+    );
+    // We always use shortened URIs currently
+    const hostedAuthorizationRequestUri = (0, core_1.joinUriParts)(
+      this.config.baseUrl,
+      [
+        options.verifier.verifierId,
+        this.config.authorizationRequestEndpoint.endpointPath,
+        // It doesn't really matter what the url is, as long as it's unique
+        core_1.utils.uuid(),
+      ]
+    );
+    // This is very unfortunate, but storing state in sphereon's SiOP-OID4VP library
+    // is done async, so we can't be certain yet that the verification session record
+    // is created already when we have created the authorization request. So we need to
+    // wait for a short while before we can be certain that the verification session record
+    // is created. To not use arbitrary timeouts, we wait for the specific RecordSavedEvent
+    // that is emitted when the verification session record is created.
+    const eventEmitter = agentContext.dependencyManager.resolve(
+      core_1.EventEmitter
+    );
+    const verificationSessionCreatedPromise = (0, rxjs_1.firstValueFrom)(
+      eventEmitter.observable(core_1.RepositoryEventTypes.RecordSaved).pipe(
+        (0, rxjs_1.filter)(
+          (e) =>
+            e.metadata.contextCorrelationId ===
+            agentContext.contextCorrelationId
+        ),
+        (0, rxjs_1.filter)(
+          (e) =>
+            e.payload.record.id === correlationId &&
+            e.payload.record.verifierId === options.verifier.verifierId
+        ),
+        (0, rxjs_1.first)(),
+        (0, rxjs_1.timeout)({
+          first: 10000,
+          meta: "OpenId4VcSiopVerifierService.createAuthorizationRequest",
+        }),
+        (0, rxjs_1.map)((e) => e.payload.record)
+      )
+    );
+    const authorizationRequest = await relyingParty.createAuthorizationRequest({
+      correlationId,
+      nonce,
+      state,
+      requestByReferenceURI: hostedAuthorizationRequestUri,
+      jwtIssuer,
+      additionalPayloadClaims: options.additionalPayloadClaims,
+    });
+    // NOTE: it's not possible to set the uri scheme when using the RP to create an auth request, only lower level
+    // functions allow this. So we need to replace the uri scheme manually.
+    let authorizationRequestUri = (await authorizationRequest.uri()).encodedUri;
+    if (options.presentationExchange && !options.idToken) {
+      authorizationRequestUri = authorizationRequestUri.replace(
+        "openid://",
+        "openid4vp://"
+      );
     }
-    async verifyAuthorizationResponse(agentContext, options) {
-        var _a;
-        // Assert state
-        options.verificationSession.assertState([
-            OpenId4VcVerificationSessionState_1.OpenId4VcVerificationSessionState.RequestUriRetrieved,
-            OpenId4VcVerificationSessionState_1.OpenId4VcVerificationSessionState.RequestCreated,
-        ]);
-        const authorizationRequest = await did_auth_siop_1.AuthorizationRequest.fromUriOrJwt(options.verificationSession.authorizationRequestJwt);
-        const requestClientId = await authorizationRequest.getMergedProperty('client_id');
-        const requestNonce = await authorizationRequest.getMergedProperty('nonce');
-        const requestState = await authorizationRequest.getMergedProperty('state');
-        const presentationDefinitionsWithLocation = await authorizationRequest.getPresentationDefinitions();
-        if (!requestNonce || !requestClientId || !requestState) {
-            throw new core_1.CredoError(`Unable to find nonce, state, or client_id in authorization request for verification session '${options.verificationSession.id}'`);
-        }
-        const authorizationResponseUrl = (0, core_1.joinUriParts)(this.config.baseUrl, [
-            options.verificationSession.verifierId,
-            this.config.authorizationEndpoint.endpointPath,
-        ]);
-        const relyingParty = await this.getRelyingParty(agentContext, options.verificationSession.verifierId, {
-            presentationDefinition: (_a = presentationDefinitionsWithLocation === null || presentationDefinitionsWithLocation === void 0 ? void 0 : presentationDefinitionsWithLocation[0]) === null || _a === void 0 ? void 0 : _a.definition,
-            clientId: requestClientId,
-            authorizationResponseUrl,
-        });
-        // This is very unfortunate, but storing state in sphereon's SiOP-OID4VP library
-        // is done async, so we can't be certain yet that the verification session record
-        // is updated already when we have verified the authorization response. So we need to
-        // wait for a short while before we can be certain that the verification session record
-        // is updated. To not use arbitrary timeouts, we wait for the specific RecordUpdatedEvent
-        // that is emitted when the verification session record is updated.
-        const eventEmitter = agentContext.dependencyManager.resolve(core_1.EventEmitter);
-        const verificationSessionUpdatedPromise = (0, rxjs_1.firstValueFrom)(eventEmitter
-            .observable(core_1.RepositoryEventTypes.RecordUpdated)
-            .pipe((0, rxjs_1.filter)((e) => e.metadata.contextCorrelationId === agentContext.contextCorrelationId), (0, rxjs_1.filter)((e) => e.payload.record.id === options.verificationSession.id &&
-            e.payload.record.verifierId === options.verificationSession.verifierId &&
-            (e.payload.record.state === OpenId4VcVerificationSessionState_1.OpenId4VcVerificationSessionState.ResponseVerified ||
-                e.payload.record.state === OpenId4VcVerificationSessionState_1.OpenId4VcVerificationSessionState.Error)), (0, rxjs_1.first)(), (0, rxjs_1.timeout)({
-            first: 10000,
-            meta: 'OpenId4VcSiopVerifierService.verifyAuthorizationResponse',
-        }), (0, rxjs_1.map)((e) => e.payload.record)));
-        await relyingParty.verifyAuthorizationResponse(options.authorizationResponse, {
-            audience: requestClientId,
-            correlationId: options.verificationSession.id,
-            state: requestState,
-            presentationDefinitions: presentationDefinitionsWithLocation,
-            verification: {
-                presentationVerificationCallback: this.getPresentationVerificationCallback(agentContext, {
-                    nonce: requestNonce,
-                    audience: requestClientId,
-                }),
-            },
-        });
-        const verificationSession = await verificationSessionUpdatedPromise;
-        const verifiedAuthorizationResponse = await this.getVerifiedAuthorizationResponse(verificationSession);
-        return Object.assign(Object.assign({}, verifiedAuthorizationResponse), { verificationSession: await verificationSessionUpdatedPromise });
+    const verificationSession = await verificationSessionCreatedPromise;
+    return {
+      authorizationRequest: authorizationRequestUri,
+      verificationSession,
+    };
+  }
+  async verifyAuthorizationResponse(agentContext, options) {
+    var _a;
+    // Assert state
+    options.verificationSession.assertState([
+      OpenId4VcVerificationSessionState_1.OpenId4VcVerificationSessionState
+        .RequestUriRetrieved,
+      OpenId4VcVerificationSessionState_1.OpenId4VcVerificationSessionState
+        .RequestCreated,
+    ]);
+    const authorizationRequest =
+      await did_auth_siop_1.AuthorizationRequest.fromUriOrJwt(
+        options.verificationSession.authorizationRequestJwt
+      );
+    const requestClientId = await authorizationRequest.getMergedProperty(
+      "client_id"
+    );
+    const requestNonce = await authorizationRequest.getMergedProperty("nonce");
+    const requestState = await authorizationRequest.getMergedProperty("state");
+    const presentationDefinitionsWithLocation =
+      await authorizationRequest.getPresentationDefinitions();
+    if (!requestNonce || !requestClientId || !requestState) {
+      throw new core_1.CredoError(
+        `Unable to find nonce, state, or client_id in authorization request for verification session '${options.verificationSession.id}'`
+      );
     }
-    // TODO: we can also choose to store this in the verification session, however we can easily derive it
-    // so it's probably easier to make changes in the future if we just store the raw payload.
-    async getVerifiedAuthorizationResponse(verificationSession) {
-        var _a, _b, _c, _d;
-        verificationSession.assertState(OpenId4VcVerificationSessionState_1.OpenId4VcVerificationSessionState.ResponseVerified);
-        if (!verificationSession.authorizationResponsePayload) {
-            throw new core_1.CredoError('No authorization response payload found in the verification session.');
-        }
-        const authorizationResponse = await did_auth_siop_1.AuthorizationResponse.fromPayload(verificationSession.authorizationResponsePayload);
-        const authorizationRequest = await did_auth_siop_1.AuthorizationRequest.fromUriOrJwt(verificationSession.authorizationRequestJwt);
-        const idToken = authorizationResponse.idToken
-            ? { payload: await ((_a = authorizationResponse.idToken) === null || _a === void 0 ? void 0 : _a.payload()) }
-            : undefined;
-        let presentationExchange = undefined;
-        const presentationDefinitions = await authorizationRequest.getPresentationDefinitions();
-        if (presentationDefinitions && presentationDefinitions.length > 0) {
-            const presentations = await (0, OpenID4VP_1.extractPresentationsFromAuthorizationResponse)(authorizationResponse, {
-                hasher: core_1.Hasher.hash,
-            });
-            // TODO: Probably wise to check against request for the location of the submission_data
-            const submission = (_d = (_c = (_b = idToken === null || idToken === void 0 ? void 0 : idToken.payload) === null || _b === void 0 ? void 0 : _b._vp_token) === null || _c === void 0 ? void 0 : _c.presentation_submission) !== null && _d !== void 0 ? _d : authorizationResponse.payload.presentation_submission;
-            if (!submission) {
-                throw new core_1.CredoError('Unable to extract submission from the response.');
-            }
-            presentationExchange = {
-                definition: presentationDefinitions[0].definition,
-                presentations: presentations.map(transform_1.getVerifiablePresentationFromSphereonWrapped),
-                submission,
-            };
+    const authorizationResponseUrl = (0, core_1.joinUriParts)(
+      this.config.baseUrl,
+      [
+        options.verificationSession.verifierId,
+        this.config.authorizationEndpoint.endpointPath,
+      ]
+    );
+    const relyingParty = await this.getRelyingParty(
+      agentContext,
+      options.verificationSession.verifierId,
+      {
+        presentationDefinition:
+          (_a =
+            presentationDefinitionsWithLocation === null ||
+            presentationDefinitionsWithLocation === void 0
+              ? void 0
+              : presentationDefinitionsWithLocation[0]) === null ||
+          _a === void 0
+            ? void 0
+            : _a.definition,
+        clientId: requestClientId,
+        authorizationResponseUrl,
+      }
+    );
+    // This is very unfortunate, but storing state in sphereon's SiOP-OID4VP library
+    // is done async, so we can't be certain yet that the verification session record
+    // is updated already when we have verified the authorization response. So we need to
+    // wait for a short while before we can be certain that the verification session record
+    // is updated. To not use arbitrary timeouts, we wait for the specific RecordUpdatedEvent
+    // that is emitted when the verification session record is updated.
+    const eventEmitter = agentContext.dependencyManager.resolve(
+      core_1.EventEmitter
+    );
+    const verificationSessionUpdatedPromise = (0, rxjs_1.firstValueFrom)(
+      eventEmitter.observable(core_1.RepositoryEventTypes.RecordUpdated).pipe(
+        (0, rxjs_1.filter)(
+          (e) =>
+            e.metadata.contextCorrelationId ===
+            agentContext.contextCorrelationId
+        ),
+        (0, rxjs_1.filter)(
+          (e) =>
+            e.payload.record.id === options.verificationSession.id &&
+            e.payload.record.verifierId ===
+              options.verificationSession.verifierId &&
+            (e.payload.record.state ===
+              OpenId4VcVerificationSessionState_1
+                .OpenId4VcVerificationSessionState.ResponseVerified ||
+              e.payload.record.state ===
+                OpenId4VcVerificationSessionState_1
+                  .OpenId4VcVerificationSessionState.Error)
+        ),
+        (0, rxjs_1.first)(),
+        (0, rxjs_1.timeout)({
+          first: 10000,
+          meta: "OpenId4VcSiopVerifierService.verifyAuthorizationResponse",
+        }),
+        (0, rxjs_1.map)((e) => e.payload.record)
+      )
+    );
+    await relyingParty.verifyAuthorizationResponse(
+      options.authorizationResponse,
+      {
+        audience: requestClientId,
+        correlationId: options.verificationSession.id,
+        state: requestState,
+        presentationDefinitions: presentationDefinitionsWithLocation,
+        verification: {
+          presentationVerificationCallback:
+            this.getPresentationVerificationCallback(agentContext, {
+              nonce: requestNonce,
+              audience: requestClientId,
+              verifyHs256Callback: options.verifyHs256Callback,
+            }),
+        },
+      }
+    );
+    const verificationSession = await verificationSessionUpdatedPromise;
+    const verifiedAuthorizationResponse =
+      await this.getVerifiedAuthorizationResponse(verificationSession);
+    return Object.assign(Object.assign({}, verifiedAuthorizationResponse), {
+      verificationSession: await verificationSessionUpdatedPromise,
+    });
+  }
+  // TODO: we can also choose to store this in the verification session, however we can easily derive it
+  // so it's probably easier to make changes in the future if we just store the raw payload.
+  async getVerifiedAuthorizationResponse(verificationSession) {
+    var _a, _b, _c, _d;
+    verificationSession.assertState(
+      OpenId4VcVerificationSessionState_1.OpenId4VcVerificationSessionState
+        .ResponseVerified
+    );
+    if (!verificationSession.authorizationResponsePayload) {
+      throw new core_1.CredoError(
+        "No authorization response payload found in the verification session."
+      );
+    }
+    const authorizationResponse =
+      await did_auth_siop_1.AuthorizationResponse.fromPayload(
+        verificationSession.authorizationResponsePayload
+      );
+    const authorizationRequest =
+      await did_auth_siop_1.AuthorizationRequest.fromUriOrJwt(
+        verificationSession.authorizationRequestJwt
+      );
+    const idToken = authorizationResponse.idToken
+      ? {
+          payload: await ((_a = authorizationResponse.idToken) === null ||
+          _a === void 0
+            ? void 0
+            : _a.payload()),
         }
-        if (!idToken && !presentationExchange) {
-            throw new core_1.CredoError('No idToken or presentationExchange found in the response.');
+      : undefined;
+    let presentationExchange = undefined;
+    const presentationDefinitions =
+      await authorizationRequest.getPresentationDefinitions();
+    if (presentationDefinitions && presentationDefinitions.length > 0) {
+      const presentations = await (0,
+      OpenID4VP_1.extractPresentationsFromAuthorizationResponse)(
+        authorizationResponse,
+        {
+          hasher: core_1.Hasher.hash,
         }
-        return {
-            idToken,
-            presentationExchange,
-        };
+      );
+      // TODO: Probably wise to check against request for the location of the submission_data
+      const submission =
+        (_d =
+          (_c =
+            (_b =
+              idToken === null || idToken === void 0
+                ? void 0
+                : idToken.payload) === null || _b === void 0
+              ? void 0
+              : _b._vp_token) === null || _c === void 0
+            ? void 0
+            : _c.presentation_submission) !== null && _d !== void 0
+          ? _d
+          : authorizationResponse.payload.presentation_submission;
+      if (!submission) {
+        throw new core_1.CredoError(
+          "Unable to extract submission from the response."
+        );
+      }
+      presentationExchange = {
+        definition: presentationDefinitions[0].definition,
+        presentations: presentations.map(
+          transform_1.getVerifiablePresentationFromSphereonWrapped
+        ),
+        submission,
+      };
     }
-    /**
-     * Find the verification session associated with an authorization response. You can optionally provide a verifier id
-     * if the verifier that the response is associated with is already known.
-     */
-    async findVerificationSessionForAuthorizationResponse(agentContext, { authorizationResponse, verifierId, }) {
-        const authorizationResponseInstance = await did_auth_siop_1.AuthorizationResponse.fromPayload(authorizationResponse).catch(() => {
-            throw new core_1.CredoError(`Unable to parse authorization response payload. ${JSON.stringify(authorizationResponse)}`);
-        });
-        const responseNonce = await authorizationResponseInstance.getMergedProperty('nonce', {
-            hasher: core_1.Hasher.hash,
-        });
-        const responseState = await authorizationResponseInstance.getMergedProperty('state', {
-            hasher: core_1.Hasher.hash,
-        });
-        const verificationSession = await this.openId4VcVerificationSessionRepository.findSingleByQuery(agentContext, {
-            nonce: responseNonce,
-            payloadState: responseState,
-            verifierId,
-        });
-        return verificationSession;
+    if (!idToken && !presentationExchange) {
+      throw new core_1.CredoError(
+        "No idToken or presentationExchange found in the response."
+      );
     }
-    async getAllVerifiers(agentContext) {
-        return this.openId4VcVerifierRepository.getAll(agentContext);
+    return {
+      idToken,
+      presentationExchange,
+    };
+  }
+  /**
+   * Find the verification session associated with an authorization response. You can optionally provide a verifier id
+   * if the verifier that the response is associated with is already known.
+   */
+  async findVerificationSessionForAuthorizationResponse(
+    agentContext,
+    { authorizationResponse, verifierId }
+  ) {
+    const authorizationResponseInstance =
+      await did_auth_siop_1.AuthorizationResponse.fromPayload(
+        authorizationResponse
+      ).catch(() => {
+        throw new core_1.CredoError(
+          `Unable to parse authorization response payload. ${JSON.stringify(
+            authorizationResponse
+          )}`
+        );
+      });
+    const responseNonce = await authorizationResponseInstance.getMergedProperty(
+      "nonce",
+      {
+        hasher: core_1.Hasher.hash,
+      }
+    );
+    const responseState = await authorizationResponseInstance.getMergedProperty(
+      "state",
+      {
+        hasher: core_1.Hasher.hash,
+      }
+    );
+    const verificationSession =
+      await this.openId4VcVerificationSessionRepository.findSingleByQuery(
+        agentContext,
+        {
+          nonce: responseNonce,
+          payloadState: responseState,
+          verifierId,
+        }
+      );
+    return verificationSession;
+  }
+  async getAllVerifiers(agentContext) {
+    return this.openId4VcVerifierRepository.getAll(agentContext);
+  }
+  async getVerifierByVerifierId(agentContext, verifierId) {
+    return this.openId4VcVerifierRepository.getByVerifierId(
+      agentContext,
+      verifierId
+    );
+  }
+  async updateVerifier(agentContext, verifier) {
+    return this.openId4VcVerifierRepository.update(agentContext, verifier);
+  }
+  async createVerifier(agentContext, options) {
+    var _a;
+    const openId4VcVerifier = new repository_1.OpenId4VcVerifierRecord({
+      verifierId:
+        (_a =
+          options === null || options === void 0
+            ? void 0
+            : options.verifierId) !== null && _a !== void 0
+          ? _a
+          : core_1.utils.uuid(),
+    });
+    await this.openId4VcVerifierRepository.save(
+      agentContext,
+      openId4VcVerifier
+    );
+    await (0, router_1.storeActorIdForContextCorrelationId)(
+      agentContext,
+      openId4VcVerifier.verifierId
+    );
+    return openId4VcVerifier;
+  }
+  async findVerificationSessionsByQuery(agentContext, query, queryOptions) {
+    return this.openId4VcVerificationSessionRepository.findByQuery(
+      agentContext,
+      query,
+      queryOptions
+    );
+  }
+  async getVerificationSessionById(agentContext, verificationSessionId) {
+    return this.openId4VcVerificationSessionRepository.getById(
+      agentContext,
+      verificationSessionId
+    );
+  }
+  async getRelyingParty(
+    agentContext,
+    verifierId,
+    {
+      idToken,
+      presentationDefinition,
+      clientId,
+      clientIdScheme,
+      authorizationResponseUrl,
     }
-    async getVerifierByVerifierId(agentContext, verifierId) {
-        return this.openId4VcVerifierRepository.getByVerifierId(agentContext, verifierId);
+  ) {
+    const signatureSuiteRegistry = agentContext.dependencyManager.resolve(
+      core_1.SignatureSuiteRegistry
+    );
+    const supportedAlgs = (0, utils_1.getSupportedJwaSignatureAlgorithms)(
+      agentContext
+    );
+    const supportedProofTypes = signatureSuiteRegistry.supportedProofTypes;
+    // Check: audience must be set to the issuer with dynamic disc otherwise self-issued.me/v2.
+    const builder = did_auth_siop_1.RP.builder();
+    const responseTypes = [];
+    if (!presentationDefinition && idToken === false) {
+      throw new core_1.CredoError(
+        "Either `presentationExchange` or `idToken` must be enabled"
+      );
     }
-    async updateVerifier(agentContext, verifier) {
-        return this.openId4VcVerifierRepository.update(agentContext, verifier);
+    if (presentationDefinition) {
+      responseTypes.push(did_auth_siop_1.ResponseType.VP_TOKEN);
     }
-    async createVerifier(agentContext, options) {
-        var _a;
-        const openId4VcVerifier = new repository_1.OpenId4VcVerifierRecord({
-            verifierId: (_a = options === null || options === void 0 ? void 0 : options.verifierId) !== null && _a !== void 0 ? _a : core_1.utils.uuid(),
-        });
-        await this.openId4VcVerifierRepository.save(agentContext, openId4VcVerifier);
-        await (0, router_1.storeActorIdForContextCorrelationId)(agentContext, openId4VcVerifier.verifierId);
-        return openId4VcVerifier;
+    if (idToken === true || !presentationDefinition) {
+      responseTypes.push(did_auth_siop_1.ResponseType.ID_TOKEN);
     }
-    async findVerificationSessionsByQuery(agentContext, query, queryOptions) {
-        return this.openId4VcVerificationSessionRepository.findByQuery(agentContext, query, queryOptions);
+    // FIXME: we now manually remove did:peer, we should probably allow the user to configure this
+    const supportedDidMethods = agentContext.dependencyManager
+      .resolve(core_1.DidsApi)
+      .supportedResolverMethods.filter((m) => m !== "peer");
+    // The OpenId4VcRelyingPartyEventHandler is a global event handler that makes sure that
+    // all the events are handled, and that the correct context is used for the events.
+    const sphereonEventEmitter = agentContext.dependencyManager
+      .resolve(
+        OpenId4VcRelyingPartyEventEmitter_1.OpenId4VcRelyingPartyEventHandler
+      )
+      .getEventEmitterForVerifier(
+        agentContext.contextCorrelationId,
+        verifierId
+      );
+    builder
+      .withResponseUri(authorizationResponseUrl)
+      .withIssuer(did_auth_siop_1.ResponseIss.SELF_ISSUED_V2)
+      .withAudience(did_auth_siop_1.RequestAud.SELF_ISSUED_V2)
+      .withSupportedVersions([
+        did_auth_siop_1.SupportedVersion.SIOPv2_D11,
+        did_auth_siop_1.SupportedVersion.SIOPv2_D12_OID4VP_D18,
+        did_auth_siop_1.SupportedVersion.SIOPv2_D12_OID4VP_D20,
+      ])
+      .withResponseMode(did_auth_siop_1.ResponseMode.DIRECT_POST)
+      .withHasher(core_1.Hasher.hash)
+      // FIXME: should allow verification of revocation
+      // .withRevocationVerificationCallback()
+      .withRevocationVerification(did_auth_siop_1.RevocationVerification.NEVER)
+      .withSessionManager(
+        new OpenId4VcRelyingPartySessionManager_1.OpenId4VcRelyingPartySessionManager(
+          agentContext,
+          verifierId
+        )
+      )
+      .withEventEmitter(sphereonEventEmitter)
+      .withResponseType(responseTypes)
+      .withCreateJwtCallback((0, utils_1.getCreateJwtCallback)(agentContext))
+      .withVerifyJwtCallback((0, utils_1.getVerifyJwtCallback)(agentContext))
+      // TODO: we should probably allow some dynamic values here
+      .withClientMetadata({
+        client_id: clientId,
+        passBy: did_auth_siop_1.PassBy.VALUE,
+        responseTypesSupported: [did_auth_siop_1.ResponseType.VP_TOKEN],
+        subject_syntax_types_supported: supportedDidMethods.map(
+          (m) => `did:${m}`
+        ),
+        vpFormatsSupported: {
+          mso_mdoc: {
+            alg: supportedAlgs,
+          },
+          jwt_vc: {
+            alg: supportedAlgs,
+          },
+          jwt_vc_json: {
+            alg: supportedAlgs,
+          },
+          jwt_vp: {
+            alg: supportedAlgs,
+          },
+          ldp_vc: {
+            proof_type: supportedProofTypes,
+          },
+          ldp_vp: {
+            proof_type: supportedProofTypes,
+          },
+          "vc+sd-jwt": {
+            kb_jwt_alg_values: supportedAlgs,
+            sd_jwt_alg_values: supportedAlgs,
+          },
+        },
+      });
+    if (clientIdScheme) {
+      builder.withClientIdScheme(clientIdScheme);
     }
-    async getVerificationSessionById(agentContext, verificationSessionId) {
-        return this.openId4VcVerificationSessionRepository.getById(agentContext, verificationSessionId);
+    if (presentationDefinition) {
+      builder.withPresentationDefinition(
+        { definition: presentationDefinition },
+        [did_auth_siop_1.PropertyTarget.REQUEST_OBJECT]
+      );
     }
-    async getRelyingParty(agentContext, verifierId, { idToken, presentationDefinition, clientId, clientIdScheme, authorizationResponseUrl, }) {
-        const signatureSuiteRegistry = agentContext.dependencyManager.resolve(core_1.SignatureSuiteRegistry);
-        const supportedAlgs = (0, utils_1.getSupportedJwaSignatureAlgorithms)(agentContext);
-        const supportedProofTypes = signatureSuiteRegistry.supportedProofTypes;
-        // Check: audience must be set to the issuer with dynamic disc otherwise self-issued.me/v2.
-        const builder = did_auth_siop_1.RP.builder();
-        const responseTypes = [];
-        if (!presentationDefinition && idToken === false) {
-            throw new core_1.CredoError('Either `presentationExchange` or `idToken` must be enabled');
-        }
-        if (presentationDefinition) {
-            responseTypes.push(did_auth_siop_1.ResponseType.VP_TOKEN);
-        }
-        if (idToken === true || !presentationDefinition) {
-            responseTypes.push(did_auth_siop_1.ResponseType.ID_TOKEN);
-        }
-        // FIXME: we now manually remove did:peer, we should probably allow the user to configure this
-        const supportedDidMethods = agentContext.dependencyManager
-            .resolve(core_1.DidsApi)
-            .supportedResolverMethods.filter((m) => m !== 'peer');
-        // The OpenId4VcRelyingPartyEventHandler is a global event handler that makes sure that
-        // all the events are handled, and that the correct context is used for the events.
-        const sphereonEventEmitter = agentContext.dependencyManager
-            .resolve(OpenId4VcRelyingPartyEventEmitter_1.OpenId4VcRelyingPartyEventHandler)
-            .getEventEmitterForVerifier(agentContext.contextCorrelationId, verifierId);
-        builder
-            .withResponseUri(authorizationResponseUrl)
-            .withIssuer(did_auth_siop_1.ResponseIss.SELF_ISSUED_V2)
-            .withAudience(did_auth_siop_1.RequestAud.SELF_ISSUED_V2)
-            .withSupportedVersions([
-            did_auth_siop_1.SupportedVersion.SIOPv2_D11,
-            did_auth_siop_1.SupportedVersion.SIOPv2_D12_OID4VP_D18,
-            did_auth_siop_1.SupportedVersion.SIOPv2_D12_OID4VP_D20,
-        ])
-            .withResponseMode(did_auth_siop_1.ResponseMode.DIRECT_POST)
-            .withHasher(core_1.Hasher.hash)
-            // FIXME: should allow verification of revocation
-            // .withRevocationVerificationCallback()
-            .withRevocationVerification(did_auth_siop_1.RevocationVerification.NEVER)
-            .withSessionManager(new OpenId4VcRelyingPartySessionManager_1.OpenId4VcRelyingPartySessionManager(agentContext, verifierId))
-            .withEventEmitter(sphereonEventEmitter)
-            .withResponseType(responseTypes)
-            .withCreateJwtCallback((0, utils_1.getCreateJwtCallback)(agentContext))
-            .withVerifyJwtCallback((0, utils_1.getVerifyJwtCallback)(agentContext))
-            // TODO: we should probably allow some dynamic values here
-            .withClientMetadata({
-            client_id: clientId,
-            passBy: did_auth_siop_1.PassBy.VALUE,
-            responseTypesSupported: [did_auth_siop_1.ResponseType.VP_TOKEN],
-            subject_syntax_types_supported: supportedDidMethods.map((m) => `did:${m}`),
-            vpFormatsSupported: {
-                mso_mdoc: {
-                    alg: supportedAlgs,
-                },
-                jwt_vc: {
-                    alg: supportedAlgs,
-                },
-                jwt_vc_json: {
-                    alg: supportedAlgs,
-                },
-                jwt_vp: {
-                    alg: supportedAlgs,
-                },
-                ldp_vc: {
-                    proof_type: supportedProofTypes,
-                },
-                ldp_vp: {
-                    proof_type: supportedProofTypes,
-                },
-                'vc+sd-jwt': {
-                    kb_jwt_alg_values: supportedAlgs,
-                    sd_jwt_alg_values: supportedAlgs,
-                },
+    if (responseTypes.includes(did_auth_siop_1.ResponseType.ID_TOKEN)) {
+      builder.withScope("openid");
+    }
+    return builder.build();
+  }
+  getPresentationVerificationCallback(agentContext, options) {
+    return async (encodedPresentation, presentationSubmission) => {
+      try {
+        this.logger.debug(
+          `Presentation response`,
+          core_1.JsonTransformer.toJSON(encodedPresentation)
+        );
+        this.logger.debug(`Presentation submission`, presentationSubmission);
+        if (!encodedPresentation)
+          throw new core_1.CredoError(
+            "Did not receive a presentation for verification."
+          );
+        let isValid;
+        // TODO: it might be better here to look at the presentation submission to know
+        // If presentation includes a ~, we assume it's an SD-JWT-VC
+        if (
+          typeof encodedPresentation === "string" &&
+          encodedPresentation.includes("~")
+        ) {
+          const sdJwtVcApi = agentContext.dependencyManager.resolve(
+            core_1.SdJwtVcApi
+          );
+          const verificationResult = await sdJwtVcApi.verify({
+            compactSdJwtVc: encodedPresentation,
+            keyBinding: {
+              audience: options.audience,
+              nonce: options.nonce,
             },
-        });
-        if (clientIdScheme) {
-            builder.withClientIdScheme(clientIdScheme);
-        }
-        if (presentationDefinition) {
-            builder.withPresentationDefinition({ definition: presentationDefinition }, [did_auth_siop_1.PropertyTarget.REQUEST_OBJECT]);
+            verifyHs256Callback: options.verifyHs256Callback,
+          });
+          isValid = verificationResult.verification.isValid;
+        } else if (
+          encodedPresentation instanceof OpenID4VP_1.MdocVerifiablePresentation
+        ) {
+          // TODO: REMOVE THIS
+          const deviceSigned = JSON.parse(
+            encodedPresentation.deviceSignedBase64Url
+          ).deviceSigned;
+          const result = await core_1.Mdoc.verifyDeviceSigned(deviceSigned);
+          isValid = result;
+        } else if (typeof encodedPresentation === "string") {
+          const verificationResult =
+            await this.w3cCredentialService.verifyPresentation(agentContext, {
+              presentation: encodedPresentation,
+              challenge: options.nonce,
+              domain: options.audience,
+            });
+          isValid = verificationResult.isValid;
+        } else {
+          const verificationResult =
+            await this.w3cCredentialService.verifyPresentation(agentContext, {
+              presentation: core_1.JsonTransformer.fromJSON(
+                encodedPresentation,
+                core_1.W3cJsonLdVerifiablePresentation
+              ),
+              challenge: options.nonce,
+              domain: options.audience,
+            });
+          isValid = verificationResult.isValid;
         }
-        if (responseTypes.includes(did_auth_siop_1.ResponseType.ID_TOKEN)) {
-            builder.withScope('openid');
+        // FIXME: we throw an error here as there's a bug in sphereon library where they
+        // don't check the returned 'verified' property and only catch errors thrown.
+        // Once https://github.com/Sphereon-Opensource/SIOP-OID4VP/pull/70 is merged we
+        // can remove this.
+        if (!isValid) {
+          throw new core_1.CredoError("Presentation verification failed.");
         }
-        return builder.build();
-    }
-    getPresentationVerificationCallback(agentContext, options) {
-        return async (encodedPresentation, presentationSubmission) => {
-            try {
-                this.logger.debug(`Presentation response`, core_1.JsonTransformer.toJSON(encodedPresentation));
-                this.logger.debug(`Presentation submission`, presentationSubmission);
-                if (!encodedPresentation)
-                    throw new core_1.CredoError('Did not receive a presentation for verification.');
-                let isValid;
-                // TODO: it might be better here to look at the presentation submission to know
-                // If presentation includes a ~, we assume it's an SD-JWT-VC
-                if (typeof encodedPresentation === 'string' && encodedPresentation.includes('~')) {
-                    const sdJwtVcApi = agentContext.dependencyManager.resolve(core_1.SdJwtVcApi);
-                    const verificationResult = await sdJwtVcApi.verify({
-                        compactSdJwtVc: encodedPresentation,
-                        keyBinding: {
-                            audience: options.audience,
-                            nonce: options.nonce,
-                        },
-                    });
-                    isValid = verificationResult.verification.isValid;
-                }
-                else if (encodedPresentation instanceof OpenID4VP_1.MdocVerifiablePresentation) {
-                    // TODO: REMOVE THIS
-                    const deviceSigned = JSON.parse(encodedPresentation.deviceSignedBase64Url).deviceSigned;
-                    const result = await core_1.Mdoc.verifyDeviceSigned(deviceSigned);
-                    isValid = result;
-                }
-                else if (typeof encodedPresentation === 'string') {
-                    const verificationResult = await this.w3cCredentialService.verifyPresentation(agentContext, {
-                        presentation: encodedPresentation,
-                        challenge: options.nonce,
-                        domain: options.audience,
-                    });
-                    isValid = verificationResult.isValid;
-                }
-                else {
-                    const verificationResult = await this.w3cCredentialService.verifyPresentation(agentContext, {
-                        presentation: core_1.JsonTransformer.fromJSON(encodedPresentation, core_1.W3cJsonLdVerifiablePresentation),
-                        challenge: options.nonce,
-                        domain: options.audience,
-                    });
-                    isValid = verificationResult.isValid;
-                }
-                // FIXME: we throw an error here as there's a bug in sphereon library where they
-                // don't check the returned 'verified' property and only catch errors thrown.
-                // Once https://github.com/Sphereon-Opensource/SIOP-OID4VP/pull/70 is merged we
-                // can remove this.
-                if (!isValid) {
-                    throw new core_1.CredoError('Presentation verification failed.');
-                }
-                return {
-                    verified: isValid,
-                };
-            }
-            catch (error) {
-                agentContext.config.logger.warn('Error occurred during verification of presentation', {
-                    error,
-                });
-                throw error;
-            }
+        return {
+          verified: isValid,
         };
-    }
+      } catch (error) {
+        agentContext.config.logger.warn(
+          "Error occurred during verification of presentation",
+          {
+            error,
+          }
+        );
+        throw error;
+      }
+    };
+  }
 };
 exports.OpenId4VcSiopVerifierService = OpenId4VcSiopVerifierService;
-exports.OpenId4VcSiopVerifierService = OpenId4VcSiopVerifierService = __decorate([
-    (0, core_1.injectable)(),
-    __param(0, (0, core_1.inject)(core_1.InjectionSymbols.Logger)),
-    __metadata("design:paramtypes", [Object, core_1.W3cCredentialService,
+exports.OpenId4VcSiopVerifierService = OpenId4VcSiopVerifierService =
+  __decorate(
+    [
+      (0, core_1.injectable)(),
+      __param(0, (0, core_1.inject)(core_1.InjectionSymbols.Logger)),
+      __metadata("design:paramtypes", [
+        Object,
+        core_1.W3cCredentialService,
         repository_1.OpenId4VcVerifierRepository,
         OpenId4VcVerifierModuleConfig_1.OpenId4VcVerifierModuleConfig,
-        repository_1.OpenId4VcVerificationSessionRepository])
-], OpenId4VcSiopVerifierService);
+        repository_1.OpenId4VcVerificationSessionRepository,
+      ]),
+    ],
+    OpenId4VcSiopVerifierService
+  );
 //# sourceMappingURL=OpenId4VcSiopVerifierService.js.map
diff --git a/build/openid4vc-verifier/OpenId4VcSiopVerifierServiceOptions.d.ts b/build/openid4vc-verifier/OpenId4VcSiopVerifierServiceOptions.d.ts
index 5abfb1bc5710849f656085593c77f3ab3898e4b7..9a23e01902dc44b8c82040c1b52485df83184eba 100644
--- a/build/openid4vc-verifier/OpenId4VcSiopVerifierServiceOptions.d.ts
+++ b/build/openid4vc-verifier/OpenId4VcSiopVerifierServiceOptions.d.ts
@@ -1,50 +1,65 @@
-import type { OpenId4VcVerificationSessionRecord } from './repository';
-import type { OpenId4VcJwtIssuer, OpenId4VcSiopAuthorizationResponsePayload, OpenId4VcSiopIdTokenPayload } from '../shared';
-import type { DifPresentationExchangeDefinition, DifPresentationExchangeSubmission, DifPresentationExchangeDefinitionV2, VerifiablePresentation } from '@credo-ts/core';
+import type { OpenId4VcVerificationSessionRecord } from "./repository";
+import type {
+  OpenId4VcJwtIssuer,
+  OpenId4VcSiopAuthorizationResponsePayload,
+  OpenId4VcSiopIdTokenPayload,
+} from "../shared";
+import type {
+  DifPresentationExchangeDefinition,
+  DifPresentationExchangeSubmission,
+  DifPresentationExchangeDefinitionV2,
+  VerifiablePresentation,
+} from "@credo-ts/core";
 export interface OpenId4VcSiopCreateAuthorizationRequestOptions {
-    /**
-     * Signing information for the request JWT. This will be used to sign the request JWT
-     * and to set the client_id and client_id_scheme for registration of client_metadata.
-     */
-    requestSigner: OpenId4VcJwtIssuer;
-    /**
-     * Whether to reuqest an ID Token. Enabled by defualt when `presentationExchange` is not provided,
-     * disabled by default when `presentationExchange` is provided.
-     */
-    idToken?: boolean;
-    /**
-     * A DIF Presentation Definition (v2) can be provided to request a Verifiable Presentation using OpenID4VP.
-     */
-    presentationExchange?: {
-        definition: DifPresentationExchangeDefinitionV2;
-    };
+  /**
+   * Signing information for the request JWT. This will be used to sign the request JWT
+   * and to set the client_id and client_id_scheme for registration of client_metadata.
+   */
+  requestSigner: OpenId4VcJwtIssuer;
+  /**
+   * Whether to reuqest an ID Token. Enabled by defualt when `presentationExchange` is not provided,
+   * disabled by default when `presentationExchange` is provided.
+   */
+  idToken?: boolean;
+  /**
+   * A DIF Presentation Definition (v2) can be provided to request a Verifiable Presentation using OpenID4VP.
+   */
+  presentationExchange?: {
+    definition: DifPresentationExchangeDefinitionV2;
+  };
+
+  additionalPayloadClaims?: Record<string, unknown>;
 }
 export interface OpenId4VcSiopVerifyAuthorizationResponseOptions {
-    /**
-     * The authorization response received from the OpenID Provider (OP).
-     */
-    authorizationResponse: OpenId4VcSiopAuthorizationResponsePayload;
+  /**
+   * The authorization response received from the OpenID Provider (OP).
+   */
+  authorizationResponse: OpenId4VcSiopAuthorizationResponsePayload;
+  verifyHs256Callback?: (
+    data: Uint8Array,
+    signatureBase64Url: string
+  ) => Promise<boolean>;
 }
 export interface OpenId4VcSiopCreateAuthorizationRequestReturn {
-    authorizationRequest: string;
-    verificationSession: OpenId4VcVerificationSessionRecord;
+  authorizationRequest: string;
+  verificationSession: OpenId4VcVerificationSessionRecord;
 }
 /**
  * Either `idToken` and/or `presentationExchange` will be present.
  */
 export interface OpenId4VcSiopVerifiedAuthorizationResponse {
-    idToken?: {
-        payload: OpenId4VcSiopIdTokenPayload;
-    };
-    presentationExchange?: {
-        submission: DifPresentationExchangeSubmission;
-        definition: DifPresentationExchangeDefinition;
-        presentations: Array<VerifiablePresentation>;
-    };
+  idToken?: {
+    payload: OpenId4VcSiopIdTokenPayload;
+  };
+  presentationExchange?: {
+    submission: DifPresentationExchangeSubmission;
+    definition: DifPresentationExchangeDefinition;
+    presentations: Array<VerifiablePresentation>;
+  };
 }
 export interface OpenId4VcSiopCreateVerifierOptions {
-    /**
-     * Id of the verifier, not the id of the verifier record. Will be exposed publicly
-     */
-    verifierId?: string;
+  /**
+   * Id of the verifier, not the id of the verifier record. Will be exposed publicly
+   */
+  verifierId?: string;
 }
diff --git a/build/openid4vc-verifier/router/authorizationEndpoint.d.ts b/build/openid4vc-verifier/router/authorizationEndpoint.d.ts
index baffab5ef01cffde68fefefdd89f561f75b59032..e8ff795488fe204e2649c17434083550acd2477a 100644
--- a/build/openid4vc-verifier/router/authorizationEndpoint.d.ts
+++ b/build/openid4vc-verifier/router/authorizationEndpoint.d.ts
@@ -1,11 +1,18 @@
-import type { Router } from 'express';
+import type { Router } from "express";
 export interface OpenId4VcSiopAuthorizationEndpointConfig {
-    /**
-     * The path at which the authorization endpoint should be made available. Note that it will be
-     * hosted at a subpath to take into account multiple tenants and verifiers.
-     *
-     * @default /authorize
-     */
-    endpointPath: string;
+  /**
+   * The path at which the authorization endpoint should be made available. Note that it will be
+   * hosted at a subpath to take into account multiple tenants and verifiers.
+   *
+   * @default /authorize
+   */
+  endpointPath: string;
+  verifyHs256Callback: (
+    agentContext: AgentContext,
+    rpEphPub: Record<string, unknown>
+  ) => (data: Uint8Array, signatureBase64Url: string) => Promise<boolean>;
 }
-export declare function configureAuthorizationEndpoint(router: Router, config: OpenId4VcSiopAuthorizationEndpointConfig): void;
+export declare function configureAuthorizationEndpoint(
+  router: Router,
+  config: OpenId4VcSiopAuthorizationEndpointConfig
+): void;
diff --git a/build/openid4vc-verifier/router/authorizationEndpoint.js b/build/openid4vc-verifier/router/authorizationEndpoint.js
index a523a1e668863929f49b50fea6786e42955e5149..84df0f257493d2094bd1da743eedeef9b82df797 100644
--- a/build/openid4vc-verifier/router/authorizationEndpoint.js
+++ b/build/openid4vc-verifier/router/authorizationEndpoint.js
@@ -2,35 +2,71 @@
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.configureAuthorizationEndpoint = configureAuthorizationEndpoint;
 const router_1 = require("../../shared/router");
+const core_1 = require("@credo-ts/core");
 const OpenId4VcSiopVerifierService_1 = require("../OpenId4VcSiopVerifierService");
 function configureAuthorizationEndpoint(router, config) {
-    router.post(config.endpointPath, async (request, response, next) => {
-        const { agentContext, verifier } = (0, router_1.getRequestContext)(request);
-        try {
-            const openId4VcVerifierService = agentContext.dependencyManager.resolve(OpenId4VcSiopVerifierService_1.OpenId4VcSiopVerifierService);
-            const isVpRequest = request.body.presentation_submission !== undefined;
-            const authorizationResponse = request.body;
-            if (isVpRequest)
-                authorizationResponse.presentation_submission = JSON.parse(request.body.presentation_submission);
-            const verificationSession = await openId4VcVerifierService.findVerificationSessionForAuthorizationResponse(agentContext, {
-                authorizationResponse,
-                verifierId: verifier.verifierId,
-            });
-            if (!verificationSession) {
-                agentContext.config.logger.warn(`No verification session found for incoming authorization response for verifier ${verifier.verifierId}`);
-                return (0, router_1.sendErrorResponse)(response, agentContext.config.logger, 404, 'invalid_request', null);
-            }
-            await openId4VcVerifierService.verifyAuthorizationResponse(agentContext, {
-                authorizationResponse: request.body,
-                verificationSession,
-            });
-            response.status(200).send();
-        }
-        catch (error) {
-            (0, router_1.sendErrorResponse)(response, agentContext.config.logger, 500, 'invalid_request', error);
-        }
-        // NOTE: if we don't call next, the agentContext session handler will NOT be called
-        next();
-    });
+  router.post(config.endpointPath, async (request, response, next) => {
+    const { agentContext, verifier } = (0, router_1.getRequestContext)(request);
+    try {
+      const openId4VcVerifierService = agentContext.dependencyManager.resolve(
+        OpenId4VcSiopVerifierService_1.OpenId4VcSiopVerifierService
+      );
+      const isVpRequest = request.body.presentation_submission !== undefined;
+      const authorizationResponse = request.body;
+      if (isVpRequest)
+        authorizationResponse.presentation_submission = JSON.parse(
+          request.body.presentation_submission
+        );
+      const verificationSession =
+        await openId4VcVerifierService.findVerificationSessionForAuthorizationResponse(
+          agentContext,
+          {
+            authorizationResponse,
+            verifierId: verifier.verifierId,
+          }
+        );
+      let verifyHs256Callback = undefined;
+      const parsedAuthorizationRequest = core_1.Jwt.fromSerializedJwt(
+        verificationSession.authorizationRequestJwt
+      );
+      const rpEphPub =
+        parsedAuthorizationRequest.payload.additionalClaims.rp_eph_pub;
+      if (rpEphPub !== null && rpEphPub !== void 0) {
+        verifyHs256Callback = config.verifyHs256Callback(
+          agentContext,
+          rpEphPub.jwk
+        );
+      }
+
+      if (!verificationSession) {
+        agentContext.config.logger.warn(
+          `No verification session found for incoming authorization response for verifier ${verifier.verifierId}`
+        );
+        return (0, router_1.sendErrorResponse)(
+          response,
+          agentContext.config.logger,
+          404,
+          "invalid_request",
+          null
+        );
+      }
+      await openId4VcVerifierService.verifyAuthorizationResponse(agentContext, {
+        authorizationResponse: request.body,
+        verificationSession,
+        verifyHs256Callback: verifyHs256Callback,
+      });
+      response.status(200).send();
+    } catch (error) {
+      (0, router_1.sendErrorResponse)(
+        response,
+        agentContext.config.logger,
+        500,
+        "invalid_request",
+        error
+      );
+    }
+    // NOTE: if we don't call next, the agentContext session handler will NOT be called
+    next();
+  });
 }
 //# sourceMappingURL=authorizationEndpoint.js.map
diff --git a/build/shared/utils.js b/build/shared/utils.js
index 5d4a74363c0c8fb78120c54b06a58346287a1155..9f1590ac6805e0513ae709922ec195528c626d93 100644
--- a/build/shared/utils.js
+++ b/build/shared/utils.js
@@ -16,121 +16,167 @@ const core_1 = require("@credo-ts/core");
  * that is planned for the 0.5.0 release.
  */
 function getSupportedJwaSignatureAlgorithms(agentContext) {
-    const supportedKeyTypes = agentContext.wallet.supportedKeyTypes;
-    // Extract the supported JWS algs based on the key types the wallet support.
-    const supportedJwaSignatureAlgorithms = supportedKeyTypes
-        // Map the supported key types to the supported JWK class
-        .map(core_1.getJwkClassFromKeyType)
-        // Filter out the undefined values
-        .filter((jwkClass) => jwkClass !== undefined)
-        // Extract the supported JWA signature algorithms from the JWK class
-        .flatMap((jwkClass) => jwkClass.supportedSignatureAlgorithms);
-    return supportedJwaSignatureAlgorithms;
+  const supportedKeyTypes = agentContext.wallet.supportedKeyTypes;
+  // Extract the supported JWS algs based on the key types the wallet support.
+  const supportedJwaSignatureAlgorithms = supportedKeyTypes
+    // Map the supported key types to the supported JWK class
+    .map(core_1.getJwkClassFromKeyType)
+    // Filter out the undefined values
+    .filter((jwkClass) => jwkClass !== undefined)
+    // Extract the supported JWA signature algorithms from the JWK class
+    .flatMap((jwkClass) => jwkClass.supportedSignatureAlgorithms);
+  return supportedJwaSignatureAlgorithms;
 }
 async function getKeyFromDid(agentContext, didUrl) {
-    const didsApi = agentContext.dependencyManager.resolve(core_1.DidsApi);
-    const didDocument = await didsApi.resolveDidDocument(didUrl);
-    const verificationMethod = didDocument.dereferenceKey(didUrl, ['authentication']);
-    return (0, core_1.getKeyFromVerificationMethod)(verificationMethod);
+  const didsApi = agentContext.dependencyManager.resolve(core_1.DidsApi);
+  const didDocument = await didsApi.resolveDidDocument(didUrl);
+  const verificationMethod = didDocument.dereferenceKey(didUrl, [
+    "authentication",
+  ]);
+  return (0, core_1.getKeyFromVerificationMethod)(verificationMethod);
 }
 function getVerifyJwtCallback(agentContext) {
-    return async (jwtVerifier, jwt) => {
-        const jwsService = agentContext.dependencyManager.resolve(core_1.JwsService);
-        if (jwtVerifier.method === 'did') {
-            const key = await getKeyFromDid(agentContext, jwtVerifier.didUrl);
-            const jwk = (0, core_1.getJwkFromKey)(key);
-            const res = await jwsService.verifyJws(agentContext, { jws: jwt.raw, jwkResolver: () => jwk });
-            return res.isValid;
-        }
-        else if (jwtVerifier.method === 'x5c' || jwtVerifier.method === 'jwk') {
-            const res = await jwsService.verifyJws(agentContext, { jws: jwt.raw });
-            return res.isValid;
-        }
-        else {
-            throw new Error(`Unsupported jwt verifier method: '${jwtVerifier.method}'`);
-        }
-    };
+  return async (jwtVerifier, jwt) => {
+    const jwsService = agentContext.dependencyManager.resolve(
+      core_1.JwsService
+    );
+    if (jwtVerifier.method === "did") {
+      const key = await getKeyFromDid(agentContext, jwtVerifier.didUrl);
+      const jwk = (0, core_1.getJwkFromKey)(key);
+      const res = await jwsService.verifyJws(agentContext, {
+        jws: jwt.raw,
+        jwkResolver: () => jwk,
+      });
+      return res.isValid;
+    } else if (jwtVerifier.method === "x5c" || jwtVerifier.method === "jwk") {
+      const res = await jwsService.verifyJws(agentContext, { jws: jwt.raw });
+      return res.isValid;
+    } else {
+      throw new Error(
+        `Unsupported jwt verifier method: '${jwtVerifier.method}'`
+      );
+    }
+  };
 }
 function getCreateJwtCallback(agentContext) {
-    return async (jwtIssuer, jwt) => {
-        const jwsService = agentContext.dependencyManager.resolve(core_1.JwsService);
-        if (jwtIssuer.method === 'did') {
-            const key = await getKeyFromDid(agentContext, jwtIssuer.didUrl);
-            const jws = await jwsService.createJwsCompact(agentContext, {
-                protectedHeaderOptions: Object.assign(Object.assign({}, jwt.header), { alg: jwtIssuer.alg, jwk: undefined }),
-                payload: core_1.JwtPayload.fromJson(jwt.payload),
-                key,
-            });
-            return jws;
-        }
-        else if (jwtIssuer.method === 'jwk') {
-            if (!jwtIssuer.jwk.kty) {
-                throw new core_1.CredoError('Missing required key type (kty) in the jwk.');
-            }
-            const jwk = (0, core_1.getJwkFromJson)(jwtIssuer.jwk);
-            const key = jwk.key;
-            const jws = await jwsService.createJwsCompact(agentContext, {
-                protectedHeaderOptions: Object.assign(Object.assign({}, jwt.header), { jwk, alg: jwtIssuer.alg }),
-                payload: core_1.JwtPayload.fromJson(jwt.payload),
-                key,
-            });
-            return jws;
-        }
-        else if (jwtIssuer.method === 'x5c') {
-            const leafCertificate = core_1.X509Service.getLeafCertificate(agentContext, { certificateChain: jwtIssuer.x5c });
-            const jws = await jwsService.createJwsCompact(agentContext, {
-                protectedHeaderOptions: Object.assign(Object.assign({}, jwt.header), { alg: jwtIssuer.alg, jwk: undefined }),
-                payload: core_1.JwtPayload.fromJson(jwt.payload),
-                key: leafCertificate.publicKey,
-            });
-            return jws;
-        }
-        throw new Error(`Unsupported jwt issuer method '${jwtIssuer.method}'`);
-    };
-}
-async function openIdTokenIssuerToJwtIssuer(agentContext, openId4VcTokenIssuer) {
-    var _a;
-    if (openId4VcTokenIssuer.method === 'did') {
-        const key = await getKeyFromDid(agentContext, openId4VcTokenIssuer.didUrl);
-        const alg = (_a = (0, core_1.getJwkClassFromKeyType)(key.keyType)) === null || _a === void 0 ? void 0 : _a.supportedSignatureAlgorithms[0];
-        if (!alg)
-            throw new core_1.CredoError(`No supported signature algorithms for key type: ${key.keyType}`);
-        return {
-            method: openId4VcTokenIssuer.method,
-            didUrl: openId4VcTokenIssuer.didUrl,
-            alg,
-        };
+  return async (jwtIssuer, jwt) => {
+    const jwsService = agentContext.dependencyManager.resolve(
+      core_1.JwsService
+    );
+    if (jwtIssuer.method === "did") {
+      const key = await getKeyFromDid(agentContext, jwtIssuer.didUrl);
+      const jws = await jwsService.createJwsCompact(agentContext, {
+        protectedHeaderOptions: Object.assign(Object.assign({}, jwt.header), {
+          alg: jwtIssuer.alg,
+          jwk: undefined,
+        }),
+        payload: core_1.JwtPayload.fromJson(jwt.payload),
+        key,
+      });
+      return jws;
+    } else if (jwtIssuer.method === "jwk") {
+      if (!jwtIssuer.jwk.kty) {
+        throw new core_1.CredoError(
+          "Missing required key type (kty) in the jwk."
+        );
+      }
+      const jwk = (0, core_1.getJwkFromJson)(jwtIssuer.jwk);
+      const key = jwk.key;
+      const jws = await jwsService.createJwsCompact(agentContext, {
+        protectedHeaderOptions: Object.assign(Object.assign({}, jwt.header), {
+          jwk,
+          alg: jwtIssuer.alg,
+        }),
+        payload: core_1.JwtPayload.fromJson(jwt.payload),
+        key,
+      });
+      return jws;
+    } else if (jwtIssuer.method === "x5c") {
+      const leafCertificate = core_1.X509Service.getLeafCertificate(
+        agentContext,
+        { certificateChain: jwtIssuer.x5c }
+      );
+      const jws = await jwsService.createJwsCompact(agentContext, {
+        protectedHeaderOptions: Object.assign(Object.assign({}, jwt.header), {
+          alg: jwtIssuer.alg,
+          jwk: undefined,
+        }),
+        payload: core_1.JwtPayload.fromJson(jwt.payload),
+        key: leafCertificate.publicKey,
+      });
+      return jws;
     }
-    else if (openId4VcTokenIssuer.method === 'x5c') {
-        const leafCertificate = core_1.X509Service.getLeafCertificate(agentContext, {
-            certificateChain: openId4VcTokenIssuer.x5c,
-        });
-        const jwk = (0, core_1.getJwkFromKey)(leafCertificate.publicKey);
-        const alg = jwk.supportedSignatureAlgorithms[0];
-        if (!alg) {
-            throw new core_1.CredoError(`No supported signature algorithms found key type: '${jwk.keyType}'`);
-        }
-        return Object.assign(Object.assign({}, openId4VcTokenIssuer), { alg });
+    throw new Error(`Unsupported jwt issuer method '${jwtIssuer.method}'`);
+  };
+}
+async function openIdTokenIssuerToJwtIssuer(
+  agentContext,
+  openId4VcTokenIssuer
+) {
+  var _a;
+  if (openId4VcTokenIssuer.method === "did") {
+    const key = await getKeyFromDid(agentContext, openId4VcTokenIssuer.didUrl);
+    const alg =
+      (_a = (0, core_1.getJwkClassFromKeyType)(key.keyType)) === null ||
+      _a === void 0
+        ? void 0
+        : _a.supportedSignatureAlgorithms[0];
+    if (!alg)
+      throw new core_1.CredoError(
+        `No supported signature algorithms for key type: ${key.keyType}`
+      );
+    return {
+      method: openId4VcTokenIssuer.method,
+      didUrl: openId4VcTokenIssuer.didUrl,
+      alg,
+    };
+  } else if (openId4VcTokenIssuer.method === "x5c") {
+    const leafCertificate = core_1.X509Service.getLeafCertificate(
+      agentContext,
+      {
+        certificateChain: openId4VcTokenIssuer.x5c,
+      }
+    );
+    const jwk = (0, core_1.getJwkFromKey)(leafCertificate.publicKey);
+    const alg = jwk.supportedSignatureAlgorithms[0];
+    if (!alg) {
+      throw new core_1.CredoError(
+        `No supported signature algorithms found key type: '${jwk.keyType}'`
+      );
     }
-    else if (openId4VcTokenIssuer.method === 'jwk') {
-        const alg = openId4VcTokenIssuer.jwk.supportedSignatureAlgorithms[0];
-        if (!alg) {
-            throw new core_1.CredoError(`No supported signature algorithms for key type: '${openId4VcTokenIssuer.jwk.keyType}'`);
-        }
-        return Object.assign(Object.assign({}, openId4VcTokenIssuer), { jwk: openId4VcTokenIssuer.jwk.toJson(), alg });
+    return Object.assign(Object.assign({}, openId4VcTokenIssuer), { alg });
+  } else if (openId4VcTokenIssuer.method === "jwk") {
+    const alg = openId4VcTokenIssuer.jwk.supportedSignatureAlgorithms[0];
+    if (!alg) {
+      throw new core_1.CredoError(
+        `No supported signature algorithms for key type: '${openId4VcTokenIssuer.jwk.keyType}'`
+      );
     }
-    throw new core_1.CredoError(`Unsupported jwt issuer method '${openId4VcTokenIssuer.method}'`);
+    return Object.assign(Object.assign({}, openId4VcTokenIssuer), {
+      jwk: openId4VcTokenIssuer.jwk.toJson(),
+      alg,
+    });
+  }
+  throw new core_1.CredoError(
+    `Unsupported jwt issuer method '${openId4VcTokenIssuer.method}'`
+  );
 }
 function getProofTypeFromKey(agentContext, key) {
-    const signatureSuiteRegistry = agentContext.dependencyManager.resolve(core_1.SignatureSuiteRegistry);
-    const supportedSignatureSuites = signatureSuiteRegistry.getAllByKeyType(key.keyType);
-    if (supportedSignatureSuites.length === 0) {
-        throw new core_1.CredoError(`Couldn't find a supported signature suite for the given key type '${key.keyType}'.`);
-    }
-    return supportedSignatureSuites[0].proofType;
+  const signatureSuiteRegistry = agentContext.dependencyManager.resolve(
+    core_1.SignatureSuiteRegistry
+  );
+  const supportedSignatureSuites = signatureSuiteRegistry.getAllByKeyType(
+    key.keyType
+  );
+  if (supportedSignatureSuites.length === 0) {
+    throw new core_1.CredoError(
+      `Couldn't find a supported signature suite for the given key type '${key.keyType}'.`
+    );
+  }
+  return supportedSignatureSuites[0].proofType;
 }
 const isCredentialOfferV1Draft13 = (credentialOffer) => {
-    return 'credential_configuration_ids' in credentialOffer;
+  return "credential_configuration_ids" in credentialOffer;
 };
 exports.isCredentialOfferV1Draft13 = isCredentialOfferV1Draft13;
 //# sourceMappingURL=utils.js.map
